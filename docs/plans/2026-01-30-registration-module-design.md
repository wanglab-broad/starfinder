# Registration Module Design

**Date:** 2026-01-30
**Status:** Approved

## Overview

Implement Phase 2 of the Python backend: registration module using DFT-based phase correlation.

## Scope

- **In scope:** 3D phase correlation (handles 2D as Z=1 case)
- **Out of scope:** Local/non-rigid registration (future phase)

## Module Structure

```
src/python/starfinder/registration/
├── __init__.py              # Public exports
├── phase_correlation.py     # Pure NumPy/SciPy implementation
├── _skimage_backend.py      # scikit-image wrapper (for comparison)
└── benchmark.py             # Benchmark utilities
```

## Public API

```python
def phase_correlate(
    fixed: np.ndarray,      # (Z, Y, X) reference volume
    moving: np.ndarray,     # (Z, Y, X) volume to align
) -> tuple[float, float, float]:
    """Returns (dz, dy, dx) shift to align moving to fixed."""

def apply_shift(
    volume: np.ndarray,     # (Z, Y, X) volume to shift
    shift: tuple[float, float, float],
) -> np.ndarray:
    """Apply shift and zero out wrapped regions."""

def register_volume(
    images: np.ndarray,     # (Z, Y, X, C) multi-channel volume
    ref_image: np.ndarray,  # (Z, Y, X) reference
    mov_image: np.ndarray,  # (Z, Y, X) moving reference
) -> tuple[np.ndarray, tuple[float, float, float]]:
    """Register all channels, returns (registered_images, shifts)."""
```

## Implementation

### NumPy/SciPy Backend (phase_correlation.py)

```python
from scipy.fft import fftn, ifftn
import numpy as np

def phase_correlate(fixed: np.ndarray, moving: np.ndarray) -> tuple[float, float, float]:
    """
    Phase correlation using DFT.

    Algorithm:
    1. Compute cross-power spectrum: FFT(fixed) * conj(FFT(moving))
    2. Inverse FFT to get correlation surface
    3. Find peak location = shift
    """
    nz, ny, nx = moving.shape

    # Cross-correlation in frequency domain
    fixed_fft = fftn(fixed)
    moving_fft = fftn(moving)
    cc = ifftn(fixed_fft * np.conj(moving_fft))

    # Find peak
    peak_idx = np.argmax(np.abs(cc))
    iz, iy, ix = np.unravel_index(peak_idx, cc.shape)

    # Convert to signed shifts (handle wrap-around)
    dz = iz if iz < nz // 2 else iz - nz
    dy = iy if iy < ny // 2 else iy - ny
    dx = ix if ix < nx // 2 else ix - nx

    return (float(dz), float(dy), float(dx))
```

### scikit-image Backend (_skimage_backend.py)

```python
from skimage.registration import phase_cross_correlation

def phase_correlate_skimage(fixed: np.ndarray, moving: np.ndarray) -> tuple[float, float, float]:
    """Wrapper around scikit-image phase_cross_correlation."""
    shift, error, diffphase = phase_cross_correlation(fixed, moving)
    return tuple(shift)
```

## Benchmark Design

### Data Source

Use synthetic images generated by `starfinder.testdata.synthetic` with multiple size presets:

```python
# Benchmark presets (extend existing synthetic generator)
BENCHMARK_PRESETS = {
    "tiny":   {"height": 128,  "width": 128,  "n_z": 5,  "n_spots": 10},
    "small":  {"height": 256,  "width": 256,  "n_z": 10, "n_spots": 20},
    "medium": {"height": 512,  "width": 512,  "n_z": 30, "n_spots": 50},
    "large":  {"height": 1024, "width": 1024, "n_z": 30, "n_spots": 100},
    "xlarge": {"height": 1496, "width": 1496, "n_z": 30, "n_spots": 150},  # cell-culture-3D
    "tissue": {"height": 3072, "width": 3072, "n_z": 30, "n_spots": 200},  # tissue-2D
}
```

### Metrics
- Shift accuracy (L2 distance from ground truth)
- Execution time (mean of 5 runs)
- Peak memory (via `tracemalloc`)
- MATLAB comparison (from saved golden outputs, if available)

### Output Format
```
| Method  | Size           | Time (s) | Memory (MB) | Shift Error |
|---------|----------------|----------|-------------|-------------|
| numpy   | 128×128×5      | 0.01     | 12          | 0.00        |
| skimage | 128×128×5      | 0.01     | 15          | 0.00        |
| numpy   | 256×256×10     | 0.02     | 45          | 0.00        |
| skimage | 256×256×10     | 0.03     | 52          | 0.00        |
| numpy   | 512×512×30     | 0.15     | 380         | 0.00        |
| skimage | 512×512×30     | 0.18     | 420         | 0.00        |
| numpy   | 1024×1024×30   | 0.55     | 1200        | 0.00        |
| skimage | 1024×1024×30   | 0.62     | 1350        | 0.00        |
| numpy   | 1496×1496×30   | 1.20     | 2400        | 0.00        |
| skimage | 1496×1496×30   | 1.35     | 2650        | 0.00        |
```

### BenchmarkResult Dataclass

```python
@dataclass
class BenchmarkResult:
    method: str                    # "numpy", "skimage", "matlab"
    size: tuple[int, int, int]     # (Z, Y, X)
    time_sec: float                # Mean execution time
    memory_peak_mb: float          # Peak memory usage
    shift_error: float             # L2 distance from ground truth
```

### Benchmark Runner

```python
def run_benchmark(
    presets: list[str] = ["small", "medium", "large"],
    methods: list[str] = ["numpy", "skimage"],
    n_runs: int = 5,
    output_dir: Path | None = None,  # Generate synthetic images here
) -> list[BenchmarkResult]:
    """
    Run benchmark using synthetic images.

    1. Generate synthetic image pairs with known shifts for each preset
    2. Run phase_correlate with each method
    3. Measure time, memory, and accuracy
    """
    ...
```

## Testing Strategy

5 tests using synthetic fixtures (mini_dataset with spots):

```python
class TestPhaseCorrelate:
    def test_zero_shift(self, mini_dataset):
        """Identical images return (0, 0, 0)."""

    def test_known_shift(self, mini_dataset):
        """Recovers integer shift applied via np.roll."""

    def test_recovers_ground_truth_shift(self, mini_dataset, mini_ground_truth):
        """Recovers inter-round shifts from synthetic ground truth."""


class TestApplyShift:
    def test_roundtrip(self, mini_dataset):
        """shift -> apply -> inverse shift preserves data."""


class TestBackendParity:
    def test_backends_match(self, mini_dataset):
        """NumPy vs scikit-image produce same results."""
```

## MATLAB Function Mapping

| MATLAB | Python | Notes |
|--------|--------|-------|
| `DFTRegister3D(fixed, moving)` | `phase_correlate(fixed, moving)` | Returns (dz, dy, dx) tuple |
| `DFTApply3D(volume, params)` | `apply_shift(volume, shift)` | Simplified API |
| `RegisterImagesGlobal(images, ref, mov)` | `register_volume(images, ref, mov)` | Multi-channel convenience |

## Dependencies

Already in pyproject.toml:
- `numpy` - FFT operations
- `scipy` - `scipy.fft` module
- `scikit-image` - `phase_cross_correlation` for comparison
